//! Linux DNS configuration
//!
//! Modifies /etc/resolv.conf to set DNS servers for VPN.
//! Backs up the original configuration for restoration.

use super::DnsManager;
use anyhow::{Context, Result};
use log::{debug, info, warn};
use std::fs;
use std::path::Path;
use std::sync::Mutex;

const RESOLV_CONF_PATH: &str = "/etc/resolv.conf";
const BACKUP_PATH: &str = "/etc/resolv.conf.anet-backup";

/// Linux DNS manager that modifies /etc/resolv.conf
pub struct LinuxDnsManager {
    /// Original resolv.conf content for restoration
    original_content: Mutex<Option<String>>,
}

impl LinuxDnsManager {
    pub fn new() -> Self {
        Self {
            original_content: Mutex::new(None),
        }
    }

    /// Check if resolv.conf is a symlink (e.g., managed by systemd-resolved)
    fn is_symlink() -> bool {
        Path::new(RESOLV_CONF_PATH)
            .symlink_metadata()
            .map(|m| m.file_type().is_symlink())
            .unwrap_or(false)
    }

    /// Build resolv.conf content with VPN DNS servers
    fn build_resolv_conf(servers: &[String]) -> String {
        let mut content = String::from("# Generated by ANet VPN\n");
        for server in servers {
            content.push_str(&format!("nameserver {}\n", server));
        }
        content
    }
}

impl DnsManager for LinuxDnsManager {
    fn set_dns(&self, servers: &[String]) -> Result<()> {
        if servers.is_empty() {
            info!("No DNS servers configured, skipping DNS setup");
            return Ok(());
        }

        // Check if resolv.conf is managed by systemd-resolved
        if Self::is_symlink() {
            warn!(
                "/etc/resolv.conf is a symlink (likely managed by systemd-resolved). \
                DNS configuration may not work as expected. \
                Consider using systemd-resolved integration instead."
            );
            // Continue anyway - user may have set up the symlink intentionally
        }

        info!("Configuring DNS servers: {:?}", servers);

        // Read and backup original content
        let original = fs::read_to_string(RESOLV_CONF_PATH)
            .context("Failed to read /etc/resolv.conf")?;

        // Store original content
        {
            let mut guard = self.original_content.lock().unwrap();
            *guard = Some(original.clone());
        }

        // Also write backup to disk in case process crashes
        if let Err(e) = fs::write(BACKUP_PATH, &original) {
            warn!("Failed to write backup file: {}", e);
        }

        // Write new resolv.conf
        let new_content = Self::build_resolv_conf(servers);
        fs::write(RESOLV_CONF_PATH, &new_content)
            .context("Failed to write /etc/resolv.conf")?;

        debug!("Wrote new resolv.conf:\n{}", new_content);
        info!("DNS configured successfully");

        Ok(())
    }

    fn restore_dns(&self) -> Result<()> {
        let original = {
            let mut guard = self.original_content.lock().unwrap();
            guard.take()
        };

        match original {
            Some(content) => {
                info!("Restoring original DNS configuration...");
                fs::write(RESOLV_CONF_PATH, &content)
                    .context("Failed to restore /etc/resolv.conf")?;

                // Remove backup file
                let _ = fs::remove_file(BACKUP_PATH);

                info!("DNS configuration restored");
            }
            None => {
                // Try to restore from backup file if in-memory backup is missing
                if Path::new(BACKUP_PATH).exists() {
                    info!("Restoring DNS from backup file...");
                    let backup = fs::read_to_string(BACKUP_PATH)
                        .context("Failed to read backup file")?;
                    fs::write(RESOLV_CONF_PATH, &backup)
                        .context("Failed to restore /etc/resolv.conf from backup")?;
                    let _ = fs::remove_file(BACKUP_PATH);
                    info!("DNS configuration restored from backup");
                } else {
                    debug!("No DNS backup found, nothing to restore");
                }
            }
        }

        Ok(())
    }
}

impl Default for LinuxDnsManager {
    fn default() -> Self {
        Self::new()
    }
}
