# =========================================================================
# ANET Server: Настройки виртуальной сети
# =========================================================================
[network]
# IP-адрес сети, которая будет создана для VPN-клиентов.
# Все клиенты будут получать IP-адреса из этого диапазона.
net = "10.0.0.0"

# Маска подсети для виртуальной сети. Определяет размер сети
# и количество доступных IP-адресов для клиентов.
mask = "255.255.255.0"

# IP-адрес шлюза внутри виртуальной сети. Этот адрес будет использоваться
# клиентами как шлюз по умолчанию для маршрутизации всего их трафика.
gateway = "10.0.0.1"

# IP-адрес, который будет присвоен TUN-интерфейсу самого сервера.
# Этот адрес должен находиться в той же подсети, что и `net`.
self_ip = "10.0.0.2"

# Имя, которое будет присвоено виртуальному сетевому TUN-интерфейсу
# на стороне сервера.
if_name = "anet-server"

# Максимальный размер пакета (MTU) для TUN-интерфейса. Этот параметр
# критически важен для производительности. Он должен быть меньше, чем MTU
# физического интерфейса, чтобы оставить место для заголовков QUIC, UDP и IP.
# Слишком большое значение может привести к фрагментации и снижению скорости.
mtu = 1300

# =========================================================================
# ANET Server: Основные настройки сервера
# =========================================================================
[server]
# IP-адрес и порт, на котором сервер будет слушать входящие UDP-соединения.
# "0.0.0.0" означает, что сервер будет принимать подключения на всех доступных
# сетевых интерфейсах.
quic_bind_to = "0.0.0.0:8443"
ssh_bind_to = "0.0.0.0:8222"
ssh_host_key = "/etc/ssh/ssh_host_rsa_key"

# Имя "внешнего" физического сетевого интерфейса сервера, через который он
# имеет выход в интернет. Этот интерфейс используется для настройки правил
# NAT (MASQUERADE), чтобы клиенты VPN могли выходить в интернет через сервер.
# Пример в Linux: "eth0", "ens3".
external_if = "eth0"

# =========================================================================
# ANET Server: Аутентификация и авторизация
# =========================================================================
[authentication]
# Список "отпечатков" (fingerprints) публичных ключей клиентов, которым
# разрешено подключаться к серверу. Отпечаток генерируется утилитой
# `anet-keygen client`. Если клиент с другим отпечатком попытается
# подключиться, его запрос будет отклонен.
allowed_clients = []

# Список URL серверов авторизации (например, ["http://127.0.0.1:3000/api/v1"])
auth_servers = []

auth_server_token = ""



# =========================================================================
# ANET Server: Криптографические ключи и сертификаты
# =========================================================================
[crypto]
# Сертификат сервера в формате PEM. Он используется для установления
# QUIC/TLS сессии. Клиент должен доверять этому сертификату.
# Содержимое файла `cert.pem` вставляется прямо сюда.
quic_cert = """
-----BEGIN CERTIFICATE-----
... (Содержимое cert.pem)
-----END CERTIFICATE-----
"""

# Приватный ключ для QUIC-сертификата в формате PEM.
# Содержимое файла `key.pem` вставляется прямо сюда.
# ВАЖНО: Храните этот ключ в секрете.
quic_key = """
-----BEGIN PRIVATE KEY-----
... (Содержимое key.pem)
-----END PRIVATE KEY-----
"""

# Приватный ключ сервера для подписи в формате Base64. Этот ключ
# используется для подписи эфемерного DH-ключа сервера на этапе рукопожатия.
# Это позволяет клиенту убедиться, что он говорит с настоящим сервером,
# а не с самозванцем. Генерируется утилитой `anet-keygen server`.
# ВАЖНО: Храните этот ключ в секрете.
server_signing_key = ""

# =========================================================================
# Настройки вывода статистики соединения
# =========================================================================
[stats]
# Включить (`true`) или выключить (`false`) периодический вывод в лог
# детальной статистики о состоянии QUIC-соединения. Полезно для
# отладки и мониторинга производительности.
# По умолчанию: false
enabled = true

# Интервал в минутах, с которым будет выводиться статистика в лог.
# Установите значение > 0.
# По умолчанию: 1
interval_minutes = 1

# =========================================================================
# Настройки маскировки трафика (Stealth)
# =========================================================================
# Эти параметры помогают скрыть факт использования VPN от систем DPI,
# изменяя размер пакетов и время их отправки.
[stealth]

# -------------------------------------------------------------------------
# Выравнивание размера пакетов (Padding)
# -------------------------------------------------------------------------
# Определяет "шаг" в байтах, до которого будет дополняться размер каждого пакета.
#
# Зачем это нужно:
# Без паддинга DPI видит реальный размер данных:
#   - 50-100 байт -> скорее всего, ввод команд в консоли (SSH) или ACK.
#   - 148 байт -> сигнатура WireGuard handshake.
#   - 1000+ байт -> передача файлов/видео.
# С паддингом все пакеты выглядят как унифицированные "кирпичи" (например, 64, 128, 192...).
# Это полностью скрывает тип активности пользователя.
#
# Значения:
#   0   - Отключено (режим "Хаос"). Пакеты имеют естественный размер.
#         Полезно против нейросетей, ищущих искусственные паттерны.
#   64  - (Рекомендуется) Баланс между скрытностью и расходом трафика.
#   128 - Высокая скрытность, но чуть больше накладных расходов (overhead).
#
# По умолчанию: 64
padding_step = 64

# -------------------------------------------------------------------------
# Имитация задержек сети (Jitter)
# -------------------------------------------------------------------------
# Добавляет случайную задержку перед отправкой каждого пакета.
# Значения указываются в наносекундах (ns).
# 1 миллисекунда (ms) = 1 000 000 наносекунд (ns).
#
# Зачем это нужно:
# DPI анализирует временные интервалы (Timing Analysis). Если пакет
# приходит на сервер и мгновенно улетает дальше, DPI понимает, что это прокси.
# Джиттер "размазывает" время доставки и меняет порядок пакетов (Reordering),
# делая поток похожим на работу обычной перегруженной сети.
#
# Рекомендации:
# 1. "Минимальный" (почти не влияет на пинг, сбивает точные тайминги):
#    min = 100000   (0.1 ms)
#    max = 500000   (0.5 ms)
#
# 2. "Сбалансированный" (хороший стелс, пинг +3мс):
#    min = 1000000  (1 ms)
#    max = 5000000  (5 ms)
#
# 3. "Параноидальный" (максимальная маскировка, пинг +15мс, возможны лаги в играх):
#    min = 5000000  (5 ms)
#    max = 20000000 (20 ms)
#
# Установите min и max в 0, чтобы отключить.

# Минимальная задержка (в наносекундах)
# По умолчанию: 1000000 (1 ms)
min_jitter_ns = 1000000

# Максимальная задержка (в наносекундах)
# По умолчанию: 5000000 (5 ms)
max_jitter_ns = 5000000

# =========================================================================
# Настройки транспорта QUIC (Quinn Transport Configuration)
# Эта секция определяет, как сервер будет управлять трафиком для всех
# подключенных клиентов. Так как сервер обслуживает множество соединений
# с разными характеристиками, настройки должны быть достаточно гибкими
# и производительными.
# =========================================================================
[quic_transport]
# -------------------------------------------------------------------------
# Алгоритм контроля перегрузки (Congestion Control Algorithm)
# -------------------------------------------------------------------------
# "bbr": Настоятельно рекомендуется для сервера. Этот алгоритм позволяет
#     эффективно работать с клиентами на самых разных типах сетей
#     (стабильных, с потерями, с высоким пингом), адаптируясь под
#     каждое соединение индивидуально.
# "cubic": Менее предпочтителен для сервера, так как может показывать
#     сниженную производительность для клиентов с нестабильным подключением.
algorithm = "bbr"

# -------------------------------------------------------------------------
# Обобщенные параметры канала
# -------------------------------------------------------------------------
# Среднеожидаемое время кругового пути (RTT) от клиентов в миллисекундах.
# Это значение используется как начальная точка для всех новых соединений.
# BBR быстро скорректирует его до реального значения для каждого клиента.
expected_rtt_ms = 60

# Оценка пропускной способности канала сервера для исходящего трафика
# (Download для клиента) в мегабитах в секунду.
# Укажите реальную скорость сетевого интерфейса вашего сервера. Это
# значение используется для автоматического расчета `send_window`.
bandwidth_down_mbps = 1000

# Оценка пропускной способности канала сервера для входящего трафика
# (Upload от клиента) в мегабитах в секунду.
# Используется для расчета `receive_window` и для настройки BBR.
bandwidth_up_mbps = 1000

# -------------------------------------------------------------------------
# Размеры буферов (Flow Control Windows)
# Рекомендуется оставить эти параметры незаполненными для автоматического расчета.
# -------------------------------------------------------------------------
# Размер окна приема для отдельного QUIC-потока от клиента, в байтах.
# Если параметр не указан, рассчитывается автоматически.
# stream_receive_window =

# Общий размер окна приема для всего соединения, в байтах. Ограничивает,
# какой объем данных сервер готов буферизовать от одного клиента.
# Напрямую влияет на скорость исходящего трафика (upload) клиента.
# Если не указан, рассчитывается на основе `bandwidth_up_mbps`.
# receive_window =

# Общий размер окна отправки, в байтах. Определяет, какой объем данных
# сервер может отправить одному клиенту без ожидания подтверждений.
# Напрямую влияет на скорость входящего трафика (download) клиента.
# Если не указан, рассчитывается на основе `bandwidth_down_mbps`.
# send_window =

# -------------------------------------------------------------------------
# Дополнительные оптимизации
# -------------------------------------------------------------------------
# Включение Generic Segmentation Offload (GSO). На сервере эта опция
# особенно важна, так как значительно снижает нагрузку на CPU при
# обслуживании множества высокоскоростных соединений.
enable_gso = true

# Таймаут неактивности соединения в секундах. Рекомендуется установить
# то же значение, что и на клиенте, для синхронного поведения.
idle_timeout_seconds = 21600

# Максимальный размер пакета для механизма Path MTU Discovery.
# Это "потолок", выше которого QUIC не будет пытаться поднять MTU.
# В 99% случаев стандартное значение 1500 является оптимальным.
# Изменяйте, только если вы точно знаете, что в вашей сети поддерживается больший MTU.
max_mtu = 1500
