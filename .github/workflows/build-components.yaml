name: "Build Components"

on:
  workflow_call:
    secrets:
      MACOS_CERTIFICATE:
        required: false
      MACOS_CERTIFICATE_PASSWORD:
        required: false
      KEYCHAIN_PASSWORD:
        required: false
      APPLE_ID:
        required: false
      APPLE_ID_PASSWORD:
        required: false
      APPLE_TEAM_ID:
        required: false
    outputs:
      server-artifact:
        value: ${{ jobs.build-linux-server.outputs.artifact }}
      linux-client-artifact:
        value: ${{ jobs.build-linux-client.outputs.artifact }}
      windows-client-artifact:
        value: ${{ jobs.build-windows-client.outputs.artifact }}
      macos-client-artifact:
        value: ${{ jobs.build-macos-client.outputs.artifact }}

jobs:
  build-linux-server:
    name: "Build Linux Server"
    runs-on: "ubuntu-latest"
    steps:
      - uses: "actions/checkout@v4"

      - name: "Install musl tools"
        run: "sudo apt-get install -y musl-tools protobuf-compiler"

      - name: "Install Rust"
        uses: "actions-rs/toolchain@v1"
        with:
          toolchain: "stable"
          target: "x86_64-unknown-linux-musl"
          override: "true"

      - name: "Cache Rust dependencies"
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-musl-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-musl-
            ${{ runner.os }}-cargo-

      - name: "Build Server"
        run: "RUSTFLAGS=\"-C target-feature=+crt-static\" cargo build --release --package anet-server --target x86_64-unknown-linux-musl"

      - uses: "actions/upload-artifact@v4"
        with:
          name: "anet-server"
          path: "target/x86_64-unknown-linux-musl/release/anet-server"

  build-linux-client:
    name: "Build Linux Client"
    runs-on: "ubuntu-latest"
    steps:
      - uses: "actions/checkout@v4"

      - name: "Install musl tools"
        run: "sudo apt-get install -y musl-tools protobuf-compiler"

      - name: "Install Rust"
        uses: "actions-rs/toolchain@v1"
        with:
          toolchain: "stable"
          target: "x86_64-unknown-linux-musl"
          override: "true"

      - name: "Cache Rust dependencies"
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-musl-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-musl-
            ${{ runner.os }}-cargo-

      - name: "Build Client (Linux)"
        run: "RUSTFLAGS=\"-C target-feature=+crt-static\" cargo build --release --package anet-client-cli --target x86_64-unknown-linux-musl"

      - uses: "actions/upload-artifact@v4"
        with:
          name: "anet-client-linux"
          path: "target/x86_64-unknown-linux-musl/release/anet-client"

  build-windows-client:
    name: "Build Windows Client"
    runs-on: "windows-latest"
    steps:
      - uses: "actions/checkout@v4"

      - name: "Install protoc (Windows)"
        run: "choco install protoc"

      - name: "Install Rust"
        uses: "actions-rs/toolchain@v1"
        with:
          toolchain: "stable"
          override: "true"

      - name: "Cache Rust dependencies"
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: "Build Client (CLI) (Windows)"
        run: "cargo build --release --package anet-client-cli"

      - uses: "actions/upload-artifact@v4"
        with:
          name: "anet-client-windows-cli"
          path: "target/release/anet-client.exe"

      - name: "Build Client (GUI) (Windows)"
        run: "cargo build --release --package anet-client-gui"

      - uses: "actions/upload-artifact@v4"
        with:
          name: "anet-client-windows-gui"
          path: "target/release/anet-gui.exe"

      - name: "Build Client (GUI - Debug Console) (Windows)"
        run: "cargo build --release --package anet-client-gui --features console"

      - name: "Remove existing debug build if exists"
        run: "if (Test-Path target/release/anet-gui-debug.exe) { Remove-Item target/release/anet-gui-debug.exe }"

      - name: "Rename Debug Build"
        run: "mv target/release/anet-gui.exe target/release/anet-gui-debug.exe"

      - uses: "actions/upload-artifact@v4"
        with:
          name: "anet-gui-debug"
          path: "target/release/anet-gui-debug.exe"

  build-macos-client:
    name: "Build macOS Client (Universal)"
    runs-on: "macos-latest"
    steps:
      - uses: "actions/checkout@v4"

      # На macOS-latest protobuf обычно есть, но для гарантии
      - name: "Install Protobuf"
        run: brew install protobuf

      - name: "Install Rust Targets (Apple Silicon & Intel)"
        run: |
          rustup target add aarch64-apple-darwin
          rustup target add x86_64-apple-darwin

      - name: "Cache Rust dependencies"
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-universal-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-universal-
            ${{ runner.os }}-cargo-

      # Сборка CLI (Intel + ARM)
      - name: "Build CLI (x86_64)"
        run: cargo build --release --package anet-client-cli --target x86_64-apple-darwin

      - name: "Build CLI (aarch64)"
        run: cargo build --release --package anet-client-cli --target aarch64-apple-darwin

      # Сборка GUI (Intel + ARM)
      - name: "Build GUI (x86_64)"
        run: cargo build --release --package anet-client-gui --target x86_64-apple-darwin

      - name: "Build GUI (aarch64)"
        run: cargo build --release --package anet-client-gui --target aarch64-apple-darwin

      # Создание Universal Binaries с помощью lipo
      - name: "Create Universal Binaries"
        run: |
          mkdir -p target/universal-release
          
          # CLI
          lipo -create -output target/universal-release/anet-client \
            target/x86_64-apple-darwin/release/anet-client \
            target/aarch64-apple-darwin/release/anet-client
          
          # GUI
          lipo -create -output target/universal-release/anet-gui \
            target/x86_64-apple-darwin/release/anet-gui \
            target/aarch64-apple-darwin/release/anet-gui
          
          echo "Universal binaries created."
          file target/universal-release/anet-client
          file target/universal-release/anet-gui

      # Упаковка в .app бандл
      - name: "Package macOS App Bundle"
        run: |
          APP_NAME="ANet VPN"
          APP_DIR="target/universal-release/$APP_NAME.app"
          CONTENTS="$APP_DIR/Contents"
          MACOS="$CONTENTS/MacOS"
          RESOURCES="$CONTENTS/Resources"
          
          mkdir -p "$MACOS"
          mkdir -p "$RESOURCES"
          
          # Копируем Universal GUI бинарник
          cp "target/universal-release/anet-gui" "$MACOS/anet-gui"
          chmod +x "$MACOS/anet-gui"
          
          # Копируем Info.plist
          cp "anet-client-gui/macos/Info.plist" "$CONTENTS/Info.plist"
          
          # Создаем PkgInfo
          echo -n "APPL????" > "$CONTENTS/PkgInfo"
          
          echo "App bundle created at $APP_DIR"

      - name: "Check Certificate Availability"
        id: check_cert
        env:
          # Безопасно передаем секрет в env, не используя его в if
          CERT: ${{ secrets.MACOS_CERTIFICATE }}
        run: |
          if [ -n "$CERT" ]; then
            echo "has_cert=true" >> $GITHUB_OUTPUT
            echo "Certificate detected."
          else
            echo "has_cert=false" >> $GITHUB_OUTPUT
            echo "Certificate NOT detected."
          fi

      - name: "Import Code Signing Certificate"
        # Используем output предыдущего шага вместо прямого доступа к secrets
        if: steps.check_cert.outputs.has_cert == 'true'
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          
          # Import certificate
          echo "$MACOS_CERTIFICATE" | base64 --decode > certificate.p12
          security import certificate.p12 -k build.keychain -P "$MACOS_CERTIFICATE_PASSWORD" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" build.keychain
          
          rm certificate.p12

      - name: "Sign App Bundle with Entitlements"
        # Используем output предыдущего шага
        if: steps.check_cert.outputs.has_cert == 'true'
        run: |
          # Find the Developer ID certificate identity
          IDENTITY=$(security find-identity -v -p codesigning build.keychain | grep "Developer ID Application" | head -1 | awk -F'"' '{print $2}')
          
          echo "Signing with identity: $IDENTITY"
          
          # Sign the app bundle
          codesign --force --deep --sign "$IDENTITY" \
            --entitlements "anet-client-gui/macos/entitlements.plist" \
            --options runtime \
            "target/universal-release/ANet VPN.app"
          
          # Sign the CLI binary
          codesign --force --sign "$IDENTITY" \
            --entitlements "anet-client-gui/macos/entitlements.plist" \
            --options runtime \
            "target/universal-release/anet-client"
          
          echo "Binaries signed with Developer ID"

      - name: "Check Notarization Credentials"
        id: check_notarize
        if: steps.check_cert.outputs.has_cert == 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          if [ -n "$APPLE_ID" ] && [ -n "$APPLE_TEAM_ID" ]; then
            echo "can_notarize=true" >> $GITHUB_OUTPUT
            echo "Notarization credentials detected."
          else
            echo "can_notarize=false" >> $GITHUB_OUTPUT
            echo "Notarization credentials NOT detected, skipping notarization."
          fi

      - name: "Notarize App Bundle"
        if: steps.check_notarize.outputs.can_notarize == 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Create a zip for notarization
          ditto -c -k --keepParent "target/universal-release/ANet VPN.app" "target/universal-release/ANet_VPN_notarize.zip"

          # Submit for notarization
          echo "Submitting app for notarization..."
          xcrun notarytool submit "target/universal-release/ANet_VPN_notarize.zip" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait

          # Staple the notarization ticket to the app
          echo "Stapling notarization ticket..."
          xcrun stapler staple "target/universal-release/ANet VPN.app"

          # Clean up
          rm "target/universal-release/ANet_VPN_notarize.zip"

          echo "App notarized and stapled successfully"

      - name: "Notarize CLI Binary"
        if: steps.check_notarize.outputs.can_notarize == 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Create a zip for CLI notarization (notarytool requires zip/dmg/pkg)
          ditto -c -k "target/universal-release/anet-client" "target/universal-release/anet-client-notarize.zip"

          # Submit for notarization
          echo "Submitting CLI for notarization..."
          xcrun notarytool submit "target/universal-release/anet-client-notarize.zip" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait

          # Note: Cannot staple standalone binaries, only .app, .pkg, .dmg
          # Clean up
          rm "target/universal-release/anet-client-notarize.zip"

          echo "CLI notarized successfully"

      - name: "Ad-hoc Sign (fallback for PRs without certificate)"
        # Используем output предыдущего шага (инверсия)
        if: steps.check_cert.outputs.has_cert != 'true'
        run: |
          echo "No certificate available, using ad-hoc signing"
          echo "Note: Ad-hoc signed binaries require sudo for TUN device access"
          
          # Sign the app bundle
          codesign --force --deep --sign - \
            --entitlements "anet-client-gui/macos/entitlements.plist" \
            "target/universal-release/ANet VPN.app"
          
          # Sign the CLI binary
          codesign --force --sign - \
            --entitlements "anet-client-gui/macos/entitlements.plist" \
            "target/universal-release/anet-client"
          
          echo "Binaries signed with ad-hoc signature"

      # Загружаем CLI отдельно (для тех, кто хочет через терминал)
      - uses: "actions/upload-artifact@v4"
        with:
          name: "anet-client-macos-cli"
          path: "target/universal-release/anet-client"

      # Загружаем .app (внутри zip, т.к. actions могут ломать права в папках)
      - name: "Zip App Bundle"
        run: |
          cd target/universal-release
          zip -r "ANet_VPN_macOS.app.zip" "ANet VPN.app"

      - uses: "actions/upload-artifact@v4"
        with:
          name: "anet-client-macos-app"
          path: "target/universal-release/ANet_VPN_macOS.app.zip"

  create-installer:
    name: "Create Windows Installer"
    runs-on: "windows-latest"
    needs: "build-windows-client"
    steps:
      - name: "Checkout repository"
        uses: "actions/checkout@v4"

      - name: "Download Client Artifact (CLI)"
        uses: "actions/download-artifact@v4"
        with:
          name: "anet-client-windows-cli"
          path: "installer_source/"

      - name: "Download Client Artifact (GUI)"
        uses: "actions/download-artifact@v4"
        with:
          name: "anet-client-windows-gui"
          path: "installer_source/"

      - name: "Download Client Artifact (GUI Debug)"
        uses: "actions/download-artifact@v4"
        with:
          name: "anet-gui-debug"
          path: "installer_source/"

      - name: "List files in installer_source for debugging"
        shell: "powershell"
        run: |
          Write-Host "Listing files in installer_source:"
          Get-ChildItem -Path "installer_source" -Recurse | Format-Table Name, FullName

      - name: "Install Inno Setup"
        shell: "powershell"
        run: "choco install -y innosetup"

      - name: "Prepare Source Files"
        shell: "powershell"
        run: |
          # Сначала проверим, какие файлы есть на самом деле
          Write-Host "Files in installer_source directory:"
          Get-ChildItem "installer_source"
          
          # Файлы уже находятся в installer_source/ напрямую (без подпапок)
          # Проверим, что они существуют перед копированием других файлов
          
          # Скачивание и размещение Wintun DLL
          $WINTUN_VERSION="0.14.1"
          Invoke-WebRequest -Uri "https://www.wintun.net/builds/wintun-$WINTUN_VERSION.zip" -OutFile "installer_source\wintun.zip"
          Expand-Archive -Path "installer_source\wintun.zip" -DestinationPath "installer_source\wintun"
          Copy-Item -Path "installer_source\wintun\wintun\bin\amd64\wintun.dll" -Destination "installer_source\wintun.dll" -Force
          Remove-Item "installer_source\wintun", "installer_source\wintun.zip" -Recurse -Force
          
          # Копирование config и ISS скрипта в рабочую директорию
          Copy-Item -Path "contrib\config\client.toml" -Destination "installer_source\client.toml" -Force
          
          # Для запуска ISCC скрипт должен быть в рабочем каталоге
          Copy-Item -Path "contrib\inno_setup\install.iss" -Destination "installer_source\install.iss" -Force
          
          # Иконка
          Copy-Item -Path "contrib\inno_setup\anet.ico" -Destination "installer_source\anet.ico" -Force
          
          # Проверка итоговых файлов
          Write-Host "Final files in installer_source:"
          Get-ChildItem "installer_source"

      - name: Set Release Version (for ISCC Define)
        shell: bash
        run: |
          if [[ "$GITHUB_REF" == refs/tags/* ]]; then
            # Для тегов: убираем 'v' в начале
            VERSION=${GITHUB_REF#refs/tags/v}
          else
            # Для веток: берем только последнюю часть после '/'
            VERSION=${GITHUB_REF##*/}
          fi
          # Очищаем версию от недопустимых символов
          CLEAN_VERSION=$(echo "$VERSION" | sed 's/[\/\\:*?"<>|]/-/g')
          echo "VERSION_ARG=/DMyAppVersion=$CLEAN_VERSION" >> $GITHUB_ENV
          echo "Clean version set to: $CLEAN_VERSION"

      - name: "Compile Inno Setup Installer (using ISCC.exe)"
        shell: "cmd"
        run: |
          "C:\Program Files (x86)\Inno Setup 6\ISCC.exe" "%GITHUB_WORKSPACE%\installer_source\install.iss" /O"%GITHUB_WORKSPACE%\installer_source\Output" ${{ env.VERSION_ARG }}

      - name: "Upload Installer Artifact"
        uses: "actions/upload-artifact@v4"
        with:
          path: installer_source\Output\*.exe
          name: anet-client-setup-windows
          if-no-files-found: error

  build-android-libs:
    name: "Build Rust for Android"
    runs-on: "ubuntu-latest"
    steps:
      - uses: "actions/checkout@v4"

      # Установка Android NDK и Rust таргетов
      - name: "Setup Android NDK"
        uses: nttld/setup-ndk@v1
        with:
          ndk-version: r26d

      - name: "Install Rust Targets"
        run: |
          rustup target add aarch64-linux-android
          rustup target add x86_64-linux-android

      - name: "Cache Rust dependencies"
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-android-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-android-
            ${{ runner.os }}-cargo-

      - name: "Install cargo-ndk"
        run: "cargo install cargo-ndk"

      - name: "Build .so libs"
        run: |
          cargo ndk -t aarch64-linux-android -o ./jniLibs build --release -p anet-mobile

      - uses: "actions/upload-artifact@v4"
        with:
          name: "anet-mobile-libs"
          path: "jniLibs/"

  package-android-apk:
    name: "Package Android APK"
    runs-on: "ubuntu-latest"
    needs: "build-android-libs"
    steps:
      - name: "Checkout Android UI Repo"
        uses: actions/checkout@v4
        with:
          repository: "ZeroTworu/anet-android"
          path: "android-ui"

      - name: "Download Rust Libs"
        uses: actions/download-artifact@v4
        with:
          name: "anet-mobile-libs"
          path: "android-ui/app/src/main/jniLibs"

      - uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: "Cache Gradle"
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: "Build APK"
        run: |
          cd android-ui
          chmod +x gradlew
          ./gradlew assembleDebug

      - uses: "actions/upload-artifact@v4"
        with:
          name: "anet-android-apk"
          path: "android-ui/app/build/outputs/apk/debug/app-debug.apk"